// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: assets.sql

package database

import (
	"context"
	"database/sql"
)

const createAsset = `-- name: CreateAsset :one
INSERT INTO "assets" (
    cmc_id, name, slug, price, 
    percent_change_1h, percent_change_24h, 
    percent_change_7d, market_cap, 
    volume_24h, circulating_supply,
    all_time_high, all_time_low,
    turnover, total_supply, 
    max_supply, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8,
    $9, $10, $11, $12, $13, $14, $15, now(), now()
) RETURNING id, cmc_id, name, slug, price, percent_change_1h, percent_change_24h, percent_change_7d, market_cap, volume_24h, circulating_supply, all_time_high, all_time_low, turnover, total_supply, max_supply, created_at, updated_at
`

type CreateAssetParams struct {
	CmcID             int64
	Name              string
	Slug              string
	Price             float64
	PercentChange1h   float32
	PercentChange24h  float32
	PercentChange7d   float32
	MarketCap         float64
	Volume24h         float64
	CirculatingSupply float32
	AllTimeHigh       float32
	AllTimeLow        float32
	Turnover          float32
	TotalSupply       float32
	MaxSupply         float32
}

func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) (Asset, error) {
	row := q.db.QueryRowContext(ctx, createAsset,
		arg.CmcID,
		arg.Name,
		arg.Slug,
		arg.Price,
		arg.PercentChange1h,
		arg.PercentChange24h,
		arg.PercentChange7d,
		arg.MarketCap,
		arg.Volume24h,
		arg.CirculatingSupply,
		arg.AllTimeHigh,
		arg.AllTimeLow,
		arg.Turnover,
		arg.TotalSupply,
		arg.MaxSupply,
	)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.CmcID,
		&i.Name,
		&i.Slug,
		&i.Price,
		&i.PercentChange1h,
		&i.PercentChange24h,
		&i.PercentChange7d,
		&i.MarketCap,
		&i.Volume24h,
		&i.CirculatingSupply,
		&i.AllTimeHigh,
		&i.AllTimeLow,
		&i.Turnover,
		&i.TotalSupply,
		&i.MaxSupply,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAsset = `-- name: GetAsset :one
SELECT id, cmc_id, name, slug, price, percent_change_1h, percent_change_24h, percent_change_7d, market_cap, volume_24h, circulating_supply, all_time_high, all_time_low, turnover, total_supply, max_supply, created_at, updated_at FROM "assets" 
WHERE cmc_id = $1 LIMIT 1
`

func (q *Queries) GetAsset(ctx context.Context, cmcID int64) (Asset, error) {
	row := q.db.QueryRowContext(ctx, getAsset, cmcID)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.CmcID,
		&i.Name,
		&i.Slug,
		&i.Price,
		&i.PercentChange1h,
		&i.PercentChange24h,
		&i.PercentChange7d,
		&i.MarketCap,
		&i.Volume24h,
		&i.CirculatingSupply,
		&i.AllTimeHigh,
		&i.AllTimeLow,
		&i.Turnover,
		&i.TotalSupply,
		&i.MaxSupply,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAssets = `-- name: ListAssets :many
SELECT id, cmc_id, name, slug, price, percent_change_1h, percent_change_24h, percent_change_7d, market_cap, volume_24h, circulating_supply, all_time_high, all_time_low, turnover, total_supply, max_supply, created_at, updated_at FROM "assets"
ORDER BY cmc_id
LIMIT $1
OFFSET $2
`

type ListAssetsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListAssets(ctx context.Context, arg ListAssetsParams) ([]Asset, error) {
	rows, err := q.db.QueryContext(ctx, listAssets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.CmcID,
			&i.Name,
			&i.Slug,
			&i.Price,
			&i.PercentChange1h,
			&i.PercentChange24h,
			&i.PercentChange7d,
			&i.MarketCap,
			&i.Volume24h,
			&i.CirculatingSupply,
			&i.AllTimeHigh,
			&i.AllTimeLow,
			&i.Turnover,
			&i.TotalSupply,
			&i.MaxSupply,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAsset = `-- name: UpdateAsset :one
UPDATE "assets"
SET
    price = coalesce($1, price),
    percent_change_1h = coalesce($2, percent_change_1h),
    percent_change_24h = coalesce($3, percent_change_24h),
    percent_change_7d = coalesce($4, percent_change_7d),
    market_cap = coalesce($5, market_cap),
    volume_24h = coalesce($6, volume_24h),
    circulating_supply = coalesce($7, circulating_supply),
    all_time_high = coalesce($8, all_time_high),
    all_time_low = coalesce($9, all_time_low),
    turnover = coalesce($10, turnover),
    total_supply = coalesce($11, total_supply),
    max_supply = coalesce($12, max_supply),
    updated_at = coalesce($13, updated_at)
    WHERE cmc_id = $14
RETURNING id, cmc_id, name, slug, price, percent_change_1h, percent_change_24h, percent_change_7d, market_cap, volume_24h, circulating_supply, all_time_high, all_time_low, turnover, total_supply, max_supply, created_at, updated_at
`

type UpdateAssetParams struct {
	Price             sql.NullFloat64
	PercentChange1h   sql.NullFloat64
	PercentChange24h  sql.NullFloat64
	PercentChange7d   sql.NullFloat64
	MarketCap         sql.NullFloat64
	Volume24h         sql.NullFloat64
	CirculatingSupply sql.NullFloat64
	AllTimeHigh       sql.NullFloat64
	AllTimeLow        sql.NullFloat64
	Turnover          sql.NullFloat64
	TotalSupply       sql.NullFloat64
	MaxSupply         sql.NullFloat64
	UpdatedAt         sql.NullTime
	CmcID             int64
}

func (q *Queries) UpdateAsset(ctx context.Context, arg UpdateAssetParams) (Asset, error) {
	row := q.db.QueryRowContext(ctx, updateAsset,
		arg.Price,
		arg.PercentChange1h,
		arg.PercentChange24h,
		arg.PercentChange7d,
		arg.MarketCap,
		arg.Volume24h,
		arg.CirculatingSupply,
		arg.AllTimeHigh,
		arg.AllTimeLow,
		arg.Turnover,
		arg.TotalSupply,
		arg.MaxSupply,
		arg.UpdatedAt,
		arg.CmcID,
	)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.CmcID,
		&i.Name,
		&i.Slug,
		&i.Price,
		&i.PercentChange1h,
		&i.PercentChange24h,
		&i.PercentChange7d,
		&i.MarketCap,
		&i.Volume24h,
		&i.CirculatingSupply,
		&i.AllTimeHigh,
		&i.AllTimeLow,
		&i.Turnover,
		&i.TotalSupply,
		&i.MaxSupply,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
